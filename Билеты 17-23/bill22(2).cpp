//Билет 22 задание 2
//Максим
//Сортировка двунаправленной очереди через указатели.
//Тут самое главное это понять как поменять местами два элемента очереди(мы не можем просто поменять информацию. В задании надо через указатели)
//Я не смогу нормально вам это объяснить( лучше нарисуйте и сами попробуйте)
#include<stdio.h>
#include<Windows.h>
#pragma warning(disable : 4996) // чтобы можно было использовать scanf fopen и т.д.
struct queu {// структура с числом и указателями для двунаправленной очереди
	int n;
	queu* left;
	queu* right;
};
void create(queu** head, queu** tail) {// функция создания двунаправленной очереди(мы предаём указатель на указатель так как нам надо менять эти указатели)
	queu* s;// структура в которую мы будем записывать информацию и потом добовлять к очереди
	s = (queu*)calloc(1, sizeof(queu));
	printf("Введите число\n");
	while (!scanf("%d", &s->n)) {// проверака на ввод числа
		rewind(stdin);// это очищение буффера( так как после scanf остаётся \n функции типо gets могут его прочитать и произойдёт прикол)
	}
	s->left = s->right = nullptr;// чтобы при чтении очереди мы могли понять когда конец
	if (!(*head) || !(*tail)) {// если очередь ещё не создана
		(*head) = *(tail) = s;//указатель головы и хвоста ставим на новую структуру
	}
	else {// если очередь уже есть
		(*tail)->right = s;//связываем хвост с новой структурой
		s->left = (*tail);// связываем новую структуру с хвостом
		(*tail) = (*tail)->right;// переходим хвостом на следующую структуру(теперь новая структура это хвост)
	}
}
void output(queu* head) {// вывод очереди(тут мы передаём просто указатель так как нам не надо изменять ничего и хватит просто копии)
	while (1) {
		printf("%d ", head->n);
		if (!head->right) {
			break;
		}
		head = head->right;
	}
}
void sort_vibor(queu** head, queu** tail) {// это сортировка отбором(если не помните погуглите как он работает)
	queu* run, * s1, * s2, * s3, * s4 = nullptr;//s1 это структура которую мы будем менять
												//run мы создадим новую структуру и свяжем правый указатель с головой(это наш бегунок который покажет
												// когда очередь закончится
												// s3 это структура перед s1
												// s2 мы будем сравнивать с s1 и так мы найдём наименьшее
												// s4 надо как тригер после первой итерации чтобы run перешол на первый элемент 
	run = (queu*)calloc(1, sizeof(queu));
	run->right = (*head);
	for (; run->right->right;) {//мы идём по очереди и когда следующий элемент от run будет последним значит мы закончили проход
		s1 = run->right;// при первом проходе s1 это голова, а s3 вообще хз(оно при первой итерации куда-то в пустоту улетает)
						// но нам норм так как если s1 самое маленькое то на перваой итерации нам не надо его менять
		s3 = s1->left;
		for (s2 = s1->right; s2; s2 = s2->right) {// цикл поиска наименьшего числа
			if (s1->n > s2->n) {
				s1 = s2;
				s3 = s1->left;
			}
		}
		if (s1 != run->right) {// если мы нашли число меньше чем в s1
			if (s1->left != run->right) {//если эти две структуры не соседние(тут лучше либо рисовать либо смотреть видос Луцика, на словах это
										// не возможно объяснить)
				if (s1->right) {// если s1 не последний элемент
					s1->right->left = run->right;
				}
				s1->left = run->right->left;
				if (run->right->right) {
					run->right->right->left = s1;
				}
				s3->right = s1->right;
				s1->right = run->right->right;
				run->right->left = s3;
				run->right->right = s3->right;
				s3->right = run->right;
				run->right = s1;
			}
			else {// если они соседние 
				if (s1->right) {
					s1->right->left = run->right;
				}
				run->right->right = s1->right;
				s1->left = run->right->left;
				s1->right = run->right;
				run->right->left = s1;
				run->right = s1;
			}
		}
		if (!s4) {// если это первая итерация то мы указатель головы ставим на s1 так как он стал(или был) превым элементом очереди
			free(s4);
			(*head) =s4 = s1;//тут надо =s4= так как нам в этот If больше не надо заходить
		}
		run = s1;// переставляем run на S1 так как он следующий по очереди
	}
	(*tail) = run->right;// так как run->right после сортировки будет в конце то указатель хвоста ставим на конец
}
void sort(queu** head, queu** tail,int n) {// это сортировка пузырьком(вроде как) в функцию мы передаём ещё и размер этой очереди
											// так как когнда мы будем сортировать наш указатель может хоть после первой итерации улететь в конец
											// и сортировка не сработает
	queu* s1, * s2;// у нас будет s1 и s2 всегда соседние(так как это пузырёк)
						// и из этой пары s1 будет слева, а s2 справо

	s1 = (*head);
	
	for (int i = 0; i < n;i++) {// проход по очереди n раз
		while (1) {// этот цикл нужен для того чтобы s1 в начале каждого прохода был на первом элементе
			if (!(s1)->left) {// если слева ничего нет то это голова(начало очереди)
				break;
			}
			(s1) = (s1)->left;
		}
		for (s1,s2 =s1->right; s2; s1 = s1->right, s2 = s2->right) {//как я говорил выше объяснить это коментами не реально(очень сложно)
																	// так что порисуйте или посмотрите объяснение Луцика


			if (s1->n < s2->n) {
				if (s2->right) {
					s2->right->left = s1;
				}
				s1->right = s2->right;
				s2->left = s1->left;
				s2->right = s1;
				if (s1->left) {
					s1->left->right = s2;
				}
				s1->left = s2;
				s1 = s2;//так как тут поменялись местами s1 и s2 то нам надо востановить чтобы s1 был слева,а s2 справо
				s2 = s2->right;
				
			}
		}
		
	}
	while (1) {// этот цикл нужен чтобы установить указатель головы на начало очереди
		if (!(*head)->left) {// елси слева ничего нет то это начало и мы выходим из очереди
			break;
		}
		(*head) = (*head)->left;
	}
	while (1) {// этот цикл нужен чтобы установить указатель хвоста на конец очереди
		if (!(*tail)->right) {//если справо ничего нет то это конец
			break;
		}
		(*tail) = (*tail)->right;
	}
	
}
int main() {
	system("chcp 1251>null"); // Тут мы меняем кодировку(так как setlocale не позволяет нам записывать строки на русском)
	queu* head, *tail;
	head = tail = nullptr;
	int n;
	printf("Введите количестово чисел\n");
	while (!scanf("%d", &n) || n<0) {// проверка на ввод числа и является ли это число >0
		rewind(stdin);// это очищение буффера( так как после scanf остаётся \n функции типо gets могут его прочитать и произойдёт прикол)
	}
	for (int i = 0; i < n; i++) {
		create(&head, &tail);
	}
	printf("Очередь до сортировки\n");
	output(head);
	/*sort_vibor(&head, &tail);*/// тут можете откоментить эту функцию и закоментить следующую чтобы посмотреть как они работают
	sort(&head, &tail,n);// и да они сортируют в разные стороны и елси их откоментить вместе то всё равно будет по убыванию
	printf("\nОчередь после сортировки\n");
	output(head);
	queu* s = head;// этот указатель нужен для очищения памяти(он будет перед головой и мы будем удалять элементы на которые он указывает)
	while (1) {// цикл для очистки памяти(мы будем идти указателем головы вправо и удалять предыдущий элемент)
		
		head = head->right;
		free(s);
		if (!head) {
			break;
		}
		s = head;
	}
	head = tail = nullptr;// так как после free в указателях остаётся мусор мы присваиваем Null
	return 0;
}