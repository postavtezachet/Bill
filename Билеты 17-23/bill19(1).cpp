//Билет 19 задание 1
// Максим
// Удаление элемента из однонаправленной очереди.

#include<stdio.h>
#include<Windows.h>
#include<locale.h>
#pragma warning(disable : 4996)// чтобы работал scanf fopen и т.д.
struct queu {// структура с числом и указателем
	int n;
	queu* next;
};
void create(queu** head, queu** tail) {// Тут мы создаём очередь(наверное на экзамене можно не писать)
									//Принимает указатель на указатель так как нам надо будет менять их
	queu* s;
	if (!(s = (queu*)calloc(1, sizeof(queu)))) {// выделяем память под структуру которую будем добовлять к очереди
		printf("Error\n");
		return;
	}
	printf("Введите число\n");
	while (!scanf("%d", &s->n)) {//Вводим число и проверяем не ввели ли мы букву
		rewind(stdin);
	}
	s->next = nullptr;// так как эта структура будет последней то указатель делаем null
						// для того чтобы норм ходить по очереди
	if (!(*head) || !(*tail)) {// если очередь ещё не создана
		(*head) = (*tail) = s;//указываем голову и хвост на нашу новую структуру

	}
	else {
		(*tail)->next = s;// указываем указателем хвоста на новую структуру
		(*tail) = (*tail)->next;// переходим хвостом на новую структуру и теперь новая структура это хвост
	}
}
void output(queu* head) {// вывод очереди (тут просто указатель так как нам надо только копия)
	while (1) {
		printf("%d ", head->n);// выводим информацию
		if (!head->next) {// если конец очереди то выходим из цикла
			break;
		}
		head = head->next;// переходим на следующий элемент очереди

	}
}
void delette(queu** head, queu** tail, int n) {// основная функция этой проги
	queu* buf, * ptr;// мы создаём два указателя buf будет на предыдущем элементе от удаляемого
					// ptr это удаляемый элемент
	int i = 1;// это счётчик какой элемент по счёту(так как мы удаляем по номеру)
	buf = (*head);
	ptr = buf->next;
	while (1) {
		if (n == 0) {// если мы ввели 1 то мы хотим удалить голову и этот if отвечает за это
			(*head) = (*head)->next;// переводим указатель головы на следующий элемент
			free(buf);// удаляем из памяти первый элемент(предыдущую голову)
			break;// и выходим из цикла
		}
		else if (!ptr->next && n==i) {// если нам надо удалить хвост
			(*tail) = buf; // переводим указатель хвоста на предыдущий элемент
			buf->next = nullptr;// обнуляем указатель нового хвоста
			free(ptr);// удаляем из памяти предыдущий хвост
			break;// выходим из цикла
		}
		else if (i == n) {// если мы удаляем какой-то элемент под номером n
			buf->next = ptr->next;// мы можно сказать переводим указатель элемента перед удаляемым на элемент после удаляемого
			free(ptr);// удаляем элемент из памяти
			break;// выходим из цикла
		}
		i++;// увеличиваем счётчик
		ptr = ptr->next;// переходим на следующий элемент
		buf = buf->next;
	}
}
int main() {
	setlocale(LC_ALL, "ru");
	queu* head, * tail;
	head = tail = nullptr;
	for (int i = 0; i < 5; i++) {// цикл для создания очереди из 5 элементов(можно другое число или написать ввод 
								// этого числа
		create(&head, &tail);
	}
	output(head);// выводим очередь
	printf("\n");
	int n;
	printf("Введите число номер числа которое хотите удалить\n");
	while (!(scanf("%d", &n) && n<=5 && n>0)) {// тут идёт проверка ввели ли вы число и это число лежит ли в пределах
												// (0,5]
		printf("Введено не верное число\n");
		rewind(stdin);
	}
	delette(&head, &tail,n-1);// в функцию отправляем n-1 так как моя функция работает если мы начинаем считать с 0
	printf("\n");
	output(head);
	return 0;
}