//Билет 23 задание 1
//Максим
//Дан отсортированный текстовый файл. Написать программу добавления русского символа, не нарушая упорядоченности.
//Тут надо вводить руские буквы без пробелов по алфавиту(в условии отсортированный)( если с пробелом то будет например так а б вг)
//Основная идея это находить букву которая дальше по алфавиту сдвинуть дальше строку и вставить букву
#include<stdio.h>
#include<Windows.h>
#include<string.h>
#pragma warning(disable : 4996)//чтобы использовать scanf fopen и т.д.
void gets_max(char* name, int n) { // I hate gets and i created this function
									//Это моя функция из лаб чтобы не было ошибки(можно использовать просто gets)
	int i = 0;
	char c;
	do {
		rewind(stdin);
		i = 0;
		c = ' ';
		int error = 0;
		while (c != '\n') {
			scanf("%c", &c);

			if (c != '\n') {
				name[i] = c;
				i++;
			}
			if (i > n) { // if input more than n
				printf("error\n");
				error = 1;
				break;
			}

		}
		if (error == 0) {
			break;
		}
	} while (1);
	name[i] = '\0';
}
void output(FILE* f) {// Ввывод файла
	char c;
	rewind(f);// переходим в начало файла
	fscanf(f, "%c", &c);
	while (1) {
		if (feof(f)) {
			break;
		}
		printf("%c", c);

		fscanf(f, "%c", &c);
	}
}
int main() {
	system("chcp 1251>null");// Тут мы меняем кодировку(так как setlocale не позволяет нам записывать строки на русском)
	char* string;// Строка которую мы будем записывать в файл
	int trig =0;
	string = (char*)calloc(100, sizeof(char));
	gets_s(string, 100);
	FILE* f;
	if (!(f = fopen("file.txt", "w+"))) {
		printf("Error\n");
		return 0;
	}
	fprintf(f, "%s", string);
	rewind(f);//переходим в начало файла

	char c,c1, c2;// в с мы записываем буквы и сравниваем с введённой буквой
				//с1 мы запоминаем символ который мы будем записывать
				//с2 мы запоминаем символ на который мы будем записывать c1
	printf("\nВведите символ который вы хотите добавить(на русском)\n");
	char symbol;
	scanf("%c", &symbol);// вводим символ который хотим добавить
	rewind(stdin);// это очищение буффера( так как после scanf остаётся \n функции типо gets могут его прочитать и произойдёт прикол)
	rewind(f);// переходим в начало файла
	while (1) {// цикл 1
		while (1) {// цикл 2
			
			fscanf(f, "%c", &c);// читаем символ из файла
			
			if (feof(f)) {// если конец файла то выходим из цикла 2
				break;
			}
			if (symbol < c && c != ' ') {// если символ позже по алфавиту и он не равен пробелу
				fseek(f, -1, 1);// переходим на предыдущий символ
				trig = 1;// этот триггер нужен чтобы понять надо ли добовлять новый символ в конец
				break;// выходим из цикла 2
			}
		}
		if (trig == 0){// если мы не нашли символ который позже в алфавите то вставляем в конец
			fprintf(f, "%c", symbol);
			break;// выходим из цикла 1
		} 
		else {
			c1 = c;// запоминаем символ который позже по алфавиту
			fprintf(f, "%c", symbol);// перезаписываем на его место введённый символ
			while (1) {//цикл 3
				fseek(f, 0, 1);// я вот реально хз почему нужна эта строчка(без неё прога не работает) хотя она просто передвигает в файле на ноль байт
								// на экзе лучше не писать
				fscanf(f, "%c", &c2);// читаем следующий элемент после с1
				if (feof(f)) {// если конец файла
					
					fprintf(f, "%c", c1);// записываем последнюю букву
					break;// выходим из цикла 3
				}
				fseek(f, -1, 1);// переходим на один символ назад
				fprintf(f, "%c", c1);//записываем c1
				
				
				c1 = c2;// в c1 запоминаем следующий символ
			}
			break;// выходим из цикла 1


		}
	}
	rewind(f);// переходим в начало файла
	printf("После добовления\n");
	output(f);
	fclose(f);

	return 0;
}