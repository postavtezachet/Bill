//Билет 18 задание 2
//Максим
//Дана однонаправленная очередь, упорядоченная по убыванию. Записать в бинарный файл, имя которого задаётся в командной строке, содержимое
//очереди по возрастанию без дополнительных массивов и файлов.
//Тут придётся вспомнить что такое командная строка
//Основная идея это пройти по очереди рекурсивно и потом когда рекурсией доходим до конца у нас она прекращается и мы в обратном порядке записываем в файл
//так как очередь по убыванию то если записать в обратном порядке то получится по возрастанию
#include<stdio.h>
#include<Windows.h>
#include<locale.h>
#pragma warning(disable : 4996)//чтобы использовать scanf fopen и т.д.
struct prekol {// структура будет содержать число и указатель чтобы создать однонаправленную очередь
	int n;
	prekol* next;
};
void create(prekol** head, prekol** tail) {//наверное это не надо на экзе, но мне надо как-то получить очередь
											//Луцик же говорил, что можно только основную функцию
	prekol* current;// 
	if (!(current = (prekol*)calloc(1, sizeof(prekol)))) {// создаём структуру которую будем добовлять к очереди
		printf("error\n");
		return;
	}
	if ((*tail)) {// тут мы проверяем есть ли у нас конец очереди
		printf("Введите число меньше чем предыдущее\n");
		while (!scanf("%d", &current->n) || current->n > (*tail)->n) {// вводим число и проверяем меньше ли оно последнего
																	// так как нам надо по убыванию
																	//И тут проверяется ввели ли мы число
			rewind(stdin);

		}
	}
	else {// если очереди ещё нет и мы вводим первое число
		printf("Введите число\n");
		while (!scanf("%d", &current->n)) {//тут проверяется не ввели ли мы число
			rewind(stdin);
		}
	}
	current->next = nullptr;//просто присваиваем указателю null так как он будет последним и чтобы мы могли нормально ходить по очереди
	if (!(*head) && !(*tail)) {// если очереди ещё нету
		(*head) = (*tail) = current;// то голову и хвост мы указываем на нашу новую структуру
	}
	else {// если очередь уже есть
		(*tail)->next = current;// мы указываем указателем хвоста на новую структуру
		(*tail) = current;// ставим хвост на новый элемент так как он последний
	}
}
void output_prekol(prekol* head) {// это функция вывода(просто проверить правильно ли работает прога)
									// она принимает просто указатель так как нам не надо оригинал(указатель на указатель)
	if (!head) {// если нету очереди то мы выходим из этой функции
		printf("No informations\n");
		return;
	}
	printf("Очередь\n");
	while (1) {//бесконечный цикл
		printf("%d ", head->n);// вывод информации
		if (head->next == nullptr) {// елси указатель Null то это конец очереди и мы выходим из цикла
			break;
		}
		head = head->next;// переход к следующему элементу
	}
}
void create_file(prekol* head,FILE* f) {// это наверное главная функция проги
	if (!(head)) {// если мы дошли до конца очереди, то выходим из рекурсии
		return;
	}
	create_file(head->next, f);// рекурсия
	fwrite(&head->n, sizeof(int), 1, f);// запись в файл
}
int main(int argc, char* argv[]) {// вспоминаем командную строку
	setlocale(LC_ALL, "ru");
	FILE* f;
	if (!(f = fopen(argv[1], "w+b"))) {// открываем файл с именем из командной строки в режиме записи и чтения
		printf("Error\n");
		return 0;
	}
	prekol* head, * tail;
	head = tail = nullptr;
	for (int i = 0; i < 5; i++) {// Создаём очередь(можете менять размер мне просто норм и так)
		create(&head, &tail);
	}
	output_prekol(head);// выводим очередь
	printf("\nФайл\n");
	create_file(head, f);// создаём файл
	int a;
	rewind(f);// переходим в начало файла
	while (1) {// выводим файл
		fread(&a, sizeof(int), 1, f);
		if (feof(f)) {// если конец то выходим из цикла
			break;
		}
		printf("%d ", a);
	}
	fclose(f);
	return 0;
}
